{"0": {
    "doc": "How To Be the Best Version of Yourself",
    "title": "How To Be the Best Version of Yourself",
    "content": "This page is adapted from the Essential Skills section of the Grittings{:target=‚Äù_blank‚Äù rel=‚Äùnoopener‚Äù} website. It highlights a set of principles I try to live by and habits I‚Äôm working on building. I‚Äôm sharing it here because it‚Äôs the kind of advice I wish I could‚Äôve given my younger self‚Äîlessons I‚Äôve picked up along the way that I hope others might find helpful. Like me, this document is still a work in progress, and I‚Äôll keep updating and editing it as I keep learning and growing. | Work. Work. Work. Do a calculation a day to keep bad spirits away. Try to convince yourself that writing code to implement a numerical method counts as doing a real (mathematical) calculation‚Äîbecause it does. | Be consistent. To quote the Jogging Baboon from BoJack Horseman: It gets easier. Every day, it gets a little easier. But you gotta do it every day‚Äîthat‚Äôs the hard part. But it does get easier. | Nobody cares. Work harder. Don‚Äôt isolate yourself in a little bubble. There‚Äôs a whole wild world out there. If you‚Äôre a theoretician, learn numerical methods and data analysis. If you‚Äôre a data analyst, understand the theoretical foundations of your work. Learn new tools. Learn new methods. Just keep learning. The rewards will follow. | Be punctual. Nobody likes to wait. If you value other people‚Äôs time, they‚Äôll return the kindness. | Discuss. You‚Äôre surrounded by smart people. Pick their brains‚Äîand let them pick yours. | Attend journal clubs. If you can‚Äôt find one, start one. If you‚Äôre interested in GR, here‚Äôs a reading list. You can also find the PDFs on the Grittings website. | Read. Read a lot. A huge part of a student‚Äôs (or a researcher‚Äôs) job is reading. I‚Äôve seen most good researchers start their day by checking the arXiv. Do the same‚Äîcheck it daily, and aim to read at least one paper a day. You don‚Äôt need to understand every detail. Instead, try to grasp the problem being addressed, why it‚Äôs interesting, and how the authors are approaching it. Getting the gist of the argument is what matters. Even if things aren‚Äôt immediately clear, this habit will give you tools that you can use later. You might even find something incredibly useful buried in an appendix of a preprint! Learning what to read is itself a learning process. Stay engaged during journal clubs. And don‚Äôt underestimate good pop science magazines‚Äîthey can help you catch important work you might have missed. It will also help to understand how to communicate your work to a non-technical audience (like your aunt). | Read some more. Make it a point to read books outside your so-called specialization. There are countless great books‚Äîfiction and non-fiction alike. Read about the lives of those who made a dent in the universe without arrogance. Keep exploring and expanding your mind. Don‚Äôt forget to understand humanity in your quest to understand the universe. | Keep reading. But eventually, try to think of something new‚Äîand then write it down. | On a more personal level: . | Always compliment people. | Be kind and respectful to everyone, regardless of past encounters. | Be generous. | Pursue what is meaningful (not what is expedient). | Do not wish for more or better. | Be precise in speech. | Do what you can, with what you have, where you are. | Compare yourself to who you were yesterday, not to who someone else is today. | Remember: one who is not satisfied with what they have will not be satisfied with what they want. | Pet a dog when you see one on the street. | . | Lastly, some words from the wise: . ‚ÄúThe pursuit of science has often been compared to the scaling of mountains, high and not so high. But who amongst us can hope, even in imagination, to scale the Everest and reach its summit when the sky is blue and the air is still, and in the stillness of the air survey the entire Himalayan range in the dazzling white of the snow stretching to infinity? None of us can hope for a comparable vision of nature and of the universe around us. But there is nothing mean or lowly in standing in the valley below and awaiting the sun to rise over Kanchenjunga.‚Äù ‚Äî Subrahmanyan Chandrasekhar, Truth and Beauty: Aesthetics and Motivations in Science (1987), p. 26. ‚ÄúDo not undertake a scientific career in quest of fame or money. There are easier and better ways to reach them. Undertake it only if nothing else will satisfy you; for nothing else is probably what you will receive. Your reward will be the widening of the horizon as you climb. And if you achieve that reward you will ask no other.‚Äù ‚Äî Cecilia Payne-Gaposchkin, as quoted by Donovan Moore in What Stars Are Made Of: The Life of Cecilia Payne-Gaposchkin (2020), p. 253. | Fin. If you‚Äôre still reading‚Äîlive long and prosper, friend! üññ ‚Äì | . ",
    "url": "/docs/advice/",
    
    "relUrl": "/docs/advice/"
  },"1": {
    "doc": "Black Holes in General Relativity and Beyond",
    "title": "Black Holes in General Relativity and Beyond",
    "content": "There is perhaps no other object in all of mathematical physics as fascinating as the black holes of Einstein‚Äôs general relativity. The notion as such is simpler than the mystique surrounding it may suggest! Loosely speaking, the black hole region $\\mathcal{B}$ of a Lorentzian 4-manifold $(\\mathcal{M}, g)$ is the complement of the causal past of a certain distinguished ideal boundary at infinity, denoted $\\mathcal{I}^+$ and known as future null infinity; in symbols . \\[\\mathcal{B} = \\mathcal{M} \\backslash J^{‚àí} (\\mathcal{I}^ + ).\\] In the context of general relativity, where our physical spacetime continuum is modelled by such a manifold \\mathcal{M}, this ideal boundary at infinity $\\mathcal{I}^+$ corresponds to ‚Äúfar-away‚Äù observers in the radiation zone of an isolated self-gravitating system such as a collapsing star. Thus, the black hole region $\\mathcal{B}$ is the set of those spacetime events which cannot send signals to distant observers like us. It is remarkable that the simplest non-trivial spacetimes $(\\mathcal{M}, g)$ solving the Einstein equations in vacuum . \\[\\mathrm{Ric}(g) = 0,\\] the celebrated Schwarzschild and Kerr solutions, indeed contain non-empty black ole regions $\\mathcal{B} \\neq \\emptyset$. ‚Äî Mihalis Dafermos, The mathematical analysis of black holes in general relativity (in Proceeding of the International Congress of Mathematicans, ICM 2014 ). ",
    "url": "/docs/blackholes/",
    
    "relUrl": "/docs/blackholes/"
  },"2": {
    "doc": "Explorations in Theoretical Physics",
    "title": "Topics by Subject",
    "content": ". life-advice . | How To Be the Best Version of Yourself | . modified-gravity . | Black Holes in General Relativity and Beyond | . nonlinear-dynamics . | Python Programming | Solving ODEs using ODEINT | . numerical-methods . | Python Programming | Solving ODEs using ODEINT | . tech-help . | Network Graph | . black-holes . | Black Holes in General Relativity and Beyond | . career-advice . | How To Be the Best Version of Yourself | . computational-physics . | Python Programming | Solving ODEs using ODEINT | . differential-equations . | Python Programming | Solving ODEs using ODEINT | . general-relativity . | Black Holes in General Relativity and Beyond | . Here are all the notes in this garden, along with their links, visualized as a graph. ",
    "url": "/",
    
    "relUrl": "/"
  },"3": {
    "doc": "Explorations in Theoretical Physics",
    "title": "Explorations in Theoretical Physics",
    "content": "These pages contain notes and references on topics in theoretical physics ‚Äì mostly classical and quantum gravity, with a strong focus on classical and quantum aspects of black holes ‚Äì and other more or less related subjects. ",
    "url": "/",
    
    "relUrl": "/"
  },"4": {
    "doc": "Solving ODEs using ODEINT",
    "title": "Solving ODEs using ODEINT",
    "content": "The motion of a nonlinear pendulum is governed by the well known equation, . \\[\\begin{align} \\dfrac{d^2 x}{d t^2} + \\sin x = 0 . \\end{align}\\] . The above equation is an example of a second-order, nonlinear ordinary differential equation (ODE). We can now introduce the following coordinate, . \\[\\begin{align} y &amp; = \\dfrac{d x}{d t}, \\end{align}\\] and converted the second order ODE into a system to two first order ODEs, viz., . \\[\\begin{align} \\dot{x} &amp; = y, \\\\ \\dot{y} &amp; = - \\sin x. \\end{align}\\] Here, dot denotes a derivative with respect to time. We can now introduce a vector \\(\\vec{S} = x \\hat{i} + y \\hat{j},\\) . and write our $2D$ system as, . \\[\\begin{align} \\dfrac{d \\vec{S}}{d t} = \\begin{bmatrix} S_2 \\\\ -\\sin S_1 \\end{bmatrix}= \\begin{bmatrix} y \\\\ -\\sin x \\end{bmatrix}, \\end{align}\\] where $S_i$ is the $i$-th component of $\\vec{S}$. Our task is to analyse the behaviour of this system, and we do that by . | drawing the phase portrait of the system, | solving the system of ODEs numerically. | . We shall use python to perfrom the above tasks. We begin by importing suitable python libraries, . | numpy to perform manipulations over numeric arrays | scipy.integrate.solve_ivp to numerically solve our ODEs | matplotlib to plot the results | seaborn to make the graphs look pretty. | . | 1 2 3 4 5 6 . | import numpy as np from scipy.integrate import odeint import matplotlib.pyplot as plt import seaborn as sns sns .set_style(\"darkgrid\") . | . Our first task is to code up a function that returns the right hand side (RHS) of the system. | 1 2 3 . | def f(S, t=0): x, y = S return [y, -np.sin(x)] . | . Notice that . | our function takes two arguments $S$ and $t$. | although our system is autonomous (that is, the RHS is independent of time), we still include the independent variable, this is because our ODE solvers are designed to accept functions which depend on both the variables. | the order of the arguments in the function signature is important, solve_ivp expects the independent variable first. | moreover, we set $t$ to take a default value $(0)$, so that can avoid passing a superficial argument while plotting the functions; we keep the $t$ to ensure we can use the same function for numerically solving the ODEs and for plotting the phase portrait. | . | . Our first order of business is to generate the phase portrait: we have to essentially sketch the vector field . \\[\\begin{align} \\dot{\\vec{S}} &amp; = \\dot{x} ~ \\hat{i} ~ + ~ \\dot{y} ~ \\hat{j},\\\\ &amp; = y ~ \\hat{i} ~ - ~ \\sin x \\hat{j}. \\end{align}\\] To plot a vector field, we need the following two functions: . | numpy.meshgrid to generate a grid of points (over the 2D plane) where we must calculate the value of the components of the vector field. | matplotlib.pyplt.streamplot to visualize a vector field by plotting the streamlines of the vector flow. | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | fig, ax = plt.subplots(figsize=(40,10)) xmin, xmax = -4.0*np.pi, 4.0*np.pi ymin, ymax = -3.0, 3.0 x = np.linspace(xmin, xmax, 30) y = np.linspace(ymin, ymax, 30) XX , YY = np.meshgrid(x, y) xdot, ydot = f([XX, YY]) ax.streamplot(XX, YY, xdot, ydot, density = 2) plt.show() . | . In the above code block, we, . | first set up the figure and axes object (if this looks unfamiliar, check this out | we then set appropriate ranges for the variables, $x$ and $y$. | we use numpy.linspace to generate 30 points along the $x$ and $y$ axes each. | we then use numpy.meshgrid to obtain two 2D arrays $XX$ and $YY$ that helps us in computing the vector field over the entire $x-y$ plane. | we store the values of the components of the vector field in xdot and ydot. | finally we use matplotlib.pyplot.streamplot to sketch the vector field. | . The primary purpose of using meshgrid is to avoid using slow python loops. To get a better understanding of how meshgrid works, check this out. Notice the line where streamplot is invoked. The basic syntax is: . ax.streamplot(x_grid,y_grid,x_vec,y_vec, density=spacing) . Here x_grid and y_grid are arrays of x, y points. The arrays x_vec and y_vec denote the stream velocity at each point on the grid. The keyword argument density=spacing specifies how close the streamlines are drawn together. We shall now use odeint to numerically solve the $2D$ system. Since, we have two differntial equations, we have to provide two initial conditions. First, shall try to simulate the case where the bob of the pendulum is initially at rest, and it is set into motion with some initial velocity, that is, . \\(x(0) = 0, ~ y(0) = c,\\) where $c$ is a constant. | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 . | fig, ax = plt.subplots(figsize=(40,10)) t0, tf = 0.0, 45.0 tspan = np.linspace(t0, tf, 1000) x0 = 0.0 c = np.linspace(-2.0, 2.0, 10) for y0 in c: S0 = [x0, y0] ys = odeint(f, S0, tspan) ax.plot(ys[:,0] , ys[:,1], 'r-') plt.show() . | . In the above code block, we: . | first set up the figure and axes object | set up the time interval over which we solve our ODEs | provide the first initial condition, $x(0)=0$ | we then construct an array containing suitable values of $c$ which we shall use to provide the second initial condition | we then run a loop that picks up one element after the other from the array containg $c$ and calls the ODE solver with the initial conditions $[0,c]$ | the solution is stored in ys and then plotted. | . We have used odeint to solve our ODEs; the syntax is ys= odeint(model, initial_values, t) where . | model is the RHS of the 2D system | initial values is an array containing the initial conditions | t is an array containing the point on the time axis where the ODEs are solved | . odeint returns a matrix which has $k$ columns, one for each of the $k$ variables, and a row for each time point specified in t. Lastly, I will change some attributes of seaborn to change the colour of the plots and define a helper function to plot arrows along the trajectories on the phase space. The detailed working of this function is not important. | 1 2 . | #define seaborn background colors sns.set(rc={'axes.facecolor': '#252a34','figure.facecolor':'#252a34'}) . | . | 1 2 3 4 5 6 7 8 9 10 . | def plotarrows(xs, ys): s = int((xs.size)/100) xs = xs.reshape(-1,s)[:,1:].flatten() ys = ys.reshape(-1,s)[:,1:].flatten() for i in range(0, xs.size, 2): dx = xs[i+1] - xs[i] dy = ys[i+1] - ys[i] ax.arrow(xs[i], ys[i], dx, dy, shape='full', lw=0, length_includes_head=True, head_width=.06, color='#ee5f5b') . | . We now put everything together. | we sketch the vector field field (that is, draw the phase portrait) | we solve the ODEs with the initial conditions . | $x(0)= 5 \\pi, y(0)= c ~ \\mathrm{where} ~ c \\in [-2, -1]$ | $x(0)= -5 \\pi, y(0)= c ~ \\mathrm{where} ~ c \\in [1, 2]$ | $x(0)= 0 \\pi, y(0)= c ~ \\mathrm{where} ~ c \\in (-2, 2)$ | and then plot everything | . | . | 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 . | fig, ax = plt.subplots(figsize=(40,10)) xmin, xmax = -4.0*np.pi, 4.0*np.pi ymin, ymax = -3.0, 3.0 x = np.linspace(xmin, xmax, 30) y = np.linspace(ymin, ymax, 30) XX , YY = np.meshgrid(x, y) xdot, ydot = f([XX, YY]) ax.streamplot(XX, YY, xdot, ydot, density = 2, color='#52adc8') t0, tf = 0.0, 45.0 tspan = np.linspace(t0, tf, 1000) x0 = 5.0*np.pi c = np.linspace(-2.0, -1.0, 4) for y0 in c: S0 = [x0, y0] ys = odeint(f, S0, tspan) ax.plot(ys[:,0] , ys[:,1], color='#ee5f5b') plotarrows(ys[:,0],ys[:,1]) x0 = -5.0*np.pi c = np.linspace(1.0, 2.0, 4) for y0 in c: S0 = [x0, y0] ys = odeint(f, S0, tspan) ax.plot(ys[:,0] , ys[:,1], color='#ee5f5b') plotarrows(ys[:,0],ys[:,1]) x0 = 0 c = np.linspace(-1.95, 1.95, 10) tspan = np.linspace(t0, tf, 300) for y0 in c: S0 = [x0, y0] ys = odeint(f, S0, tspan) ax.plot(ys[:,0] , ys[:,1], color='#ee5f5b') plotarrows(ys[:,0],ys[:,1]) ax.set_xlim(xmin, xmax) ax.set_ylim(ymin, ymax) # uncomment for grid lines but no labels # ax.set(yticklabels=[]) # hide y labels # ax.set(xticklabels=[]) # hide x labels plt.axis('off') plt.show() fig.savefig(\"header.png\", dpi=300) . | . References: . [1] Nonlinear Dynamics and Chaos, 2nd Ed by Steven Strogatz, CRC Press (2015). ",
    "url": "/docs/ode/",
    
    "relUrl": "/docs/ode/"
  },"5": {
    "doc": "Python Programming",
    "title": "Tutorials:",
    "content": ". | Solving ODEs using odeint ‚Äì Solving ODEs using ODEINT. | . ",
    "url": "/docs/python/#tutorials",
    
    "relUrl": "/docs/python/#tutorials"
  },"6": {
    "doc": "Python Programming",
    "title": "Python Programming",
    "content": " ",
    "url": "/docs/python/",
    
    "relUrl": "/docs/python/"
  },"7": {
    "doc": "Network Graph",
    "title": "Network Graph",
    "content": "under construction . ",
    "url": "/testing/",
    
    "relUrl": "/testing/"
  }
}
